### C++ 자료구조 및 알고리즘 학습 목차

#### 1. 자료구조
1.1. 배열 (Array)
1.1.1. 배열의 정의 및 기본 연산
1.1.2. 배열의 장단점
1.1.3. 동적 배열 (Dynamic Array)

1.2. 연결 리스트 (Linked List)
1.2.1. 단일 연결 리스트 (Singly Linked List)
1.2.2. 이중 연결 리스트 (Doubly Linked List)
1.2.3. 원형 연결 리스트 (Circular Linked List)

1.3. 스택 (Stack)
1.3.1. 스택의 정의 및 기본 연산
1.3.2. 스택의 활용 (예: 괄호 검사, 역순 문자열 등)

1.4. 큐 (Queue)
1.4.1. 큐의 정의 및 기본 연산
1.4.2. 원형 큐 (Circular Queue)
1.4.3. 덱 (Deque, Double-ended Queue)

1.5. 해시 테이블 (Hash Table)
1.5.1. 해싱의 개념
1.5.2. 충돌 해결 기법 (개방 주소법, 체이닝)

1.6. 트리 (Tree)
1.6.1. 트리의 기본 개념 및 용어
1.6.2. 이진 트리 (Binary Tree)
1.6.3. 이진 탐색 트리 (Binary Search Tree, BST)
1.6.4. AVL 트리 (AVL Tree)
1.6.5. 레드-블랙 트리 (Red-Black Tree)
1.6.6. 힙 (Heap) - 최대 힙, 최소 힙

1.7. 그래프 (Graph)
1.7.1. 그래프의 정의 및 기본 용어
1.7.2. 그래프의 표현 방법 (인접 행렬, 인접 리스트)
1.7.3. 방향 그래프와 무방향 그래프 (Directed and Undirected Graphs)

1.8. 트라이 (Trie)
1.8.1. 트라이의 개념 및 활용
1.8.2. 접미사 트리 (Suffix Tree)

#### 2. 알고리즘
2.1. 정렬 알고리즘 (Sorting Algorithms)
2.1.1. 버블 정렬 (Bubble Sort)
2.1.2. 선택 정렬 (Selection Sort)
2.1.3. 삽입 정렬 (Insertion Sort)
2.1.4. 병합 정렬 (Merge Sort)
2.1.5. 퀵 정렬 (Quick Sort)
2.1.6. 힙 정렬 (Heap Sort)
2.1.7. 기수 정렬 (Radix Sort)
2.1.8. 계수 정렬 (Counting Sort)

2.2. 탐색 알고리즘 (Searching Algorithms)
2.2.1. 선형 탐색 (Linear Search)
2.2.2. 이진 탐색 (Binary Search)
2.2.3. 이진 탐색 트리 탐색 (BST Search)

2.3. 재귀 (Recursion)
2.3.1. 재귀의 개념 및 기본 예제
2.3.2. 꼬리 재귀 (Tail Recursion)
2.3.3. 재귀와 메모이제이션 (Memoization)

2.4. 분할 정복 (Divide and Conquer)
2.4.1. 분할 정복의 개념
2.4.2. 병합 정렬 및 퀵 정렬

2.5. 동적 계획법 (Dynamic Programming)
2.5.1. 동적 계획법의 개념
2.5.2. 피보나치 수열
2.5.3. 최장 공통 부분 수열 (Longest Common Subsequence)
2.5.4. 배낭 문제 (Knapsack Problem)

2.6. 그리디 알고리즘 (Greedy Algorithm)
2.6.1. 그리디 알고리즘의 개념
2.6.2. 거스름돈 문제
2.6.3. 최소 신장 트리 (Minimum Spanning Tree) - 크루스칼, 프림

2.7. 그래프 알고리즘 (Graph Algorithms)
2.7.1. 깊이 우선 탐색 (Depth-First Search, DFS)
2.7.2. 너비 우선 탐색 (Breadth-First Search, BFS)
2.7.3. 다익스트라 알고리즘 (Dijkstra's Algorithm)
2.7.4. 플로이드-워셜 알고리즘 (Floyd-Warshall Algorithm)
2.7.5. 벨만-포드 알고리즘 (Bellman-Ford Algorithm)
2.7.6. 위상 정렬 (Topological Sorting)

2.8. 문자열 알고리즘 (String Algorithms)
2.8.1. 문자열 매칭 알고리즘 (String Matching Algorithms)
2.8.2. KMP 알고리즘 (Knuth-Morris-Pratt Algorithm)
2.8.3. 라빈-카프 알고리즘 (Rabin-Karp Algorithm)
2.8.4. 보이어-무어 알고리즘 (Boyer-Moore Algorithm)

2.9. 기하 알고리즘 (Geometric Algorithms)
2.9.1. 볼록 껍질 (Convex Hull)
2.9.2. 선분 교차 판별 (Line Segment Intersection)

2.10. 기타 알고리즘 (Miscellaneous Algorithms)
2.10.1. 백트래킹 (Backtracking)
2.10.2. 분지 한정 (Branch and Bound)
2.10.3. 유전 알고리즘 (Genetic Algorithm)
2.10.4. 시뮬레이티드 어닐링 (Simulated Annealing)

#### 3. 고급 자료구조 및 알고리즘
3.1. 고급 자료구조
3.1.1. 비트 마스크 (Bitmask)
3.1.2. 구간 트리 (Segment Tree)
3.1.3. 펜윅 트리 (Fenwick Tree)
3.1.4. 스플레이 트리 (Splay Tree)
3.1.5. 비머지 트리 (B-Tree)
3.1.6. 피보나치 힙 (Fibonacci Heap)

3.2. 고급 알고리즘
3.2.1. 네트워크 플로우 (Network Flow)
3.2.2. 최대 유량 (Maximum Flow)
3.2.3. 최소 비용 최대 유량 (Minimum Cost Maximum Flow)
3.2.4. 매칭 이론 (Matching Theory)
3.2.5. 이분 그래프 매칭 (Bipartite Graph Matching)
